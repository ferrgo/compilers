Lexic

// Na nossa linguagem, os comentários começam com ! e vão até o fim da linha

LETTER  		->  [a-z]|[A-Z]
DIGIT   		->  [0-9]
ID      		->  LETTER(LETTER|DIGIT|_)*

LIT_INTEGER ->  DIGIT+
LIT_LOGICAL ->  .true. | .false.
LITERAL			->  LIT_INTEGER | LIT_LOGICAL
// LIT = literal

OP_COMP 		->  <|<=|>|>=|==|!=
OP_ARIT 		->  +|-|*|/

EOT         -> "\0000"

LP          -> (
RP          -> )

TOKEN   		->  ID | LIT_INTEGER | LIT_LOGICAL| OP_COMP | OP_ARIT | ; | :: | = | LP | RP
			   | IF | THEN | ELSE | END | ELSE | DO | WHILE | EXIT | LOGICAL | INTEGER
			   | PROGRAM | FUNCTION | SUBROUTINE | PRINT | EOT

** Nem todos os simbolos estao como tipo de token (ex.: EOT) - DONE
** Verificar se todas as palavras reservadas aqui sao usadas na sintatica e vice-versa (ex.: SUBROUTINE)

__________________________________________________________________________________________________________________________________________

Syntactic

PROGRAM       ::= (FUNCTION_DECL)* PROGR_MAIN (FUNCTION_DECL)* EOT

** Simplifica e considera que todas as funcoes como declaradas antes da main.
** Não precisa usar EOL para marcar o final de linha. - DONE
** Existem linguagens que o EOL é um token, mas no nosso caso, vamos ignorar. - DONE
** Sua gramatica permite a declaracao de variaveis globais?!

PROG_MAIN     ::= PROGRAM ID (STATEMENT)* END PROGRAM ID EOT
STATEMENT     ::= (EXPRESSION | DECLARATION | ASSIGNMENT | IF_STATEMENT | LOOP)

** Qual o sentido de uma expressao sozinha como um statement?
** Faltam comandos como: chamada de funcao, retornar um valor (exp), break e continue... olhar o que é pedido

IF_STATEMENT  ::= IF EXPRESSION THEN (STATEMENT)* ( ELSE STATEMENT)* END IF EOT

** Pode simplificar e considerar somente estruturas do tipo if-else. - DONE

LOOP 				  ::= DO WHILE LP EXPRESSION RP (STATEMENT)* END DO EOT

DECLARATION   ::= TYPE :: DECLARED_VARS
DECLARED_VARS ::= ID (,ID)*
ASSIGNMENT 		::= ID = EXPRESSION

EXPRESSION      ::= EXPRESSION_ARIT (operadores_comparativos EXPRESSION_ARIT)?
EXPRESSION_ARIT    ::= EXPRESSION_ARIT (+|-) TERM | TERM
TERM          ::= TERM (*|/) FACTOR | FACTOR
FACTOR        ::= ID | LITERAL | FUNCTION_CALL | LP EXPRESSION_ARIT RP

** Falta suporte para expressoes booleanas (comparativas)

FUNCTION_CALL ::= ID LP EXPRESSION(,EXPRESSION)* RP

** E se a funcao nao tiver parametros?

FUNCTION_DECL ::= TYPE ID LP (ID(,ID)*)? RP (STATEMENT)* END FUNCTION

** Qual o tipo dos parametros?

//DECL = declaration

PRINT_STMT    ::= PRINT *, ID (,ID)*
// 	STMT = statement

** Pode fazer o print de somente um valor por vez (expressao)
