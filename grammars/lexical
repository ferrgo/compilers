Lexic

// Na nossa linguagem, os comentários começam com ! e vão até o fim da linha

LETTER  		->  [a-z]|[A-Z]
DIGIT   		->  [0-9]
ID      		->  LETTER(LETTER|DIGIT|_)*

LIT_INTEGER ->  DIGIT+
LIT_LOGICAL ->  .true. | .false.
LITERAL			->  LIT_INTEGER | LIT_LOGICAL
// LIT = literal

OP_COMP 		->  <|<=|>|>=|==|!=
OP_ARIT 		->  +|-|*|/

EOL         -> "\n\r" | "\n"
EOT         -> "\0000"

LP          -> (
RP          -> )

TOKEN   		->  ID | LIT_INTEGER | LIT_LOGICAL| OP_COMP | OP_ARIT | ; | :: | = | LP | RP
			   | IF | THEN | ELSE | END | ELSE | DO | WHILE | EXIT | LOGICAL | INTEGER
			   | PROGRAM | FUNCTION | SUBROUTINE | PRINT
** Nem todos os simbolos estao como tipo de token (ex.: EOT)
** Verificar se todas as palavras reservadas aqui sao usadas na sintatica e vice-versa (ex.: SUBROUTINE)
__________________________________________________________________________________________________________________________________________

Syntactic

PROGRAM       ::= (FUNCTION_DECL EOL)* PROGR_MAIN (FUNCTION_DECL EOL)* EOT
** Simplifica e considera que todas as funcoes como declaradas antes da main.
** Não precisa usar EOL para marcar o final de linha. Existem linguagens que o EOL é um token, mas no nosso caso, vamos ignorar.
** Sua gramatica permite a declaracao de variaveis globais?!

PROG_MAIN     ::= PROGRAM ID EOL (STATEMENT)* END PROGRAM ID EOL EOT
STATEMENT     ::= (EXPRESSION | DECLARATION | ASSIGNMENT | IF_STATEMENT | LOOP) EOL
** Qual o sentido de uma expressao sozinha como um statement?
** Faltam comandos como: chamada de funcao, retornar um valor (exp), break e continue... olhar o que é pedido

IF_STATEMENT  ::= IF EXPRESSION THEN EOL (STATEMENT)* ( ELSE (IF EXPRESSION THEN EOL)? (STATEMENT)*)* END IF EOL
** Pode simplificar e considerar somente estruturas do tipo if-else.
LOOP 				  ::= DO WHILE LP EXPRESSION RP EOL (STATEMENT)* END DO EOL

DECLARATION   ::= TYPE :: DECLARED_VARS
DECLARED_VARS ::= ID (,ID)*
ASSIGNMENT 		::= ID = EXPRESSION

EXPRESSION      ::= EXPRESSION_ARIT (operadores_comparativos EXPRESSION_ARIT)?
EXPRESSION_ARIT    ::= EXPRESSION_ARIT (+|-) TERM | TERM
TERM          ::= TERM (*|/) FACTOR | FACTOR
FACTOR        ::= ID | LITERAL | FUNCTION_CALL | LP EXPRESSION_ARIT RP
** Falta suporte para expressoes booleanas (comparativas)

FUNCTION_CALL ::= ID LP EXPRESSION(,EXPRESSION)* RP
** E se a funcao nao tiver parametros?

FUNCTION_DECL ::= TYPE ID LP (ID(,ID)*)? RP EOL (STATEMENT)* END FUNCTION
** Qual o tipo dos parametros?

//DECL = declaration

PRINT_STMT    ::= PRINT *, ID (,ID)*
// 	STMT = statement
** Pode fazer o print de somente um valor por vez (expressao)
