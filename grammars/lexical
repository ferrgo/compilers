Lexic

// Na nossa linguagem, os comentários começam com ! e vão até o fim da linha

LETTER  		->  [a-z]|[A-Z]
DIGIT   		->  [0-9]
ID      		->  LETTER(LETTER|DIGIT|_)*

LIT_INTEGER ->  DIGIT+
LIT_LOGICAL ->  .true. | .false.
LITERAL			->  LIT_INTEGER | LIT_LOGICAL

OP_COMP 		->  <|<=|>|>=|==|!=
OP_ARIT 		->  +|-|*|/

EOL         -> "\n\r" | "\n"
EOT         -> "\0000"

LP          -> (
RP          -> )

TOKEN   		->  ID | LIT_INTEGER | LIT_LOGICAL| OP_COMP | OP_ARIT | ; | :: | = | LP | RP
			   | IF | THEN | ELSE | END | ELSE | DO | WHILE | EXIT | LOGICAL | INTEGER
			   | PROGRAM | FUNCTION | SUBROUTINE | PRINT
__________________________________________________________________________________________________________________________________________

Syntactic

PROGRAM       ::= (FUNCTION_DECL EOL)* PROGRAM_MAIN (FUNCTION_DECL EOL)* EOT

PROG_MAIN     ::= PROGRAM ID EOL (STATEMENT)* END PROGRAM ID EOL EOT
STATEMENT     ::= (EXPRESSION | DECLARATION | ASSIGNMENT | IF_STATEMENT | LOOP) EOL

IF_STATEMENT  ::= IF EXPRESSION THEN EOL (STATEMENT)* ( (ELSE | ELSE IF EXPRESSION) (STATEMENT)*)? END IF EOL
LOOP 				  ::= DO WHILE LP EXPRESSION RP EOL (STATEMENT)* END DO EOL

DECLARATION   ::= TYPE :: DECLARED_VARS
DECLARED_VARS ::= ID (,ID)*
ASSIGNMENT 		::= ID = EXPRESSION

EXPRESSION    ::= EXPRESSION (+|-) TERM | TERM
TERM          ::= TERM (*|/) FACTOR | FACTOR
FACTOR        ::= ID | LITERAL | FUNCTION_CALL | ID | LP EXPRESSION RP

FUNCTION_CALL ::= ID(EXPRESSION(,EXPRESSION)*)
FUNCTION_DECL ::= TYPE ID ((ID(,ID)*)?) EOL (STATEMENT)* END FUNCTION

PRINT_STMT    ::= PRINT *, ID (,ID)*
